{% comment %}
  Include expects:
    - collections: comma-separated collection names (e.g., "home_computers, ibm_portables")
    - progress_values: comma-separated progress values to include (default: "done")
    - sort_fields: comma-separated fields to sort by (default: "released")
{% endcomment %}

{% assign collections = include.collections | split: "," %}
{% assign sort_fields = include.sort_fields | default: "released" | split: "," %}
{% assign progress_values = include.progress_values | default: "done" | split: "," %}

{% for collection_name in collections %}
  {% assign collection_items = site[collection_name] %}
  {% assign filtered_items = "" | split: "" %}
  
  {%- comment -%} Filter by allowed progress values {%- endcomment -%}
  {% for value in progress_values %}
    {% assign matching_items = collection_items | where: "progress", value %}
    {% if matching_items %}
      {% assign filtered_items = filtered_items | concat: matching_items %}
    {% endif %}
  {% endfor %}

  {%- comment -%}
    Build sort keys in parallel array
    sort_key = concatenation of configured fields + normalized order (fallback=1)
  {%- endcomment -%}
  {% assign sort_keys = "" | split: "" %}
  {% for item in filtered_items %}
    {% assign key_parts = "" | split: "" %}
    {% for field in sort_fields %}
      {% assign value = item[field] | default: "" %}
      {% assign key_parts = key_parts | push: value %}
    {% endfor %}
    {% assign order_value = item.order | default: 1 %}
    {% assign key_parts = key_parts | push: order_value %}
    {% assign sort_key = key_parts | join: "||" %}
    {% assign sort_keys = sort_keys | push: sort_key %}
  {% endfor %}

  {%- comment -%}
    Sort items by sort_key array
    Create array of indices according to sorted order_keys
  {%- endcomment -%}
  {% assign indices = "" | split: "" %}
  {% for i in (0..sort_keys.size-1) %}
    {% assign indices = indices | push: i %}
  {% endfor %}
  {% assign sorted_indices = indices | sort: "sort_keys[forloop.index0]" %} <!-- workaround won't work in Liquid -->

  {%- comment -%}
    Liquid kann leider nicht direkt Array von Indizes sortieren nach parallelem Array.
    Daher einfacher: wir bauen ein Array von hashes: { "item": item, "key": sort_key } und sortieren das.
  {%- endcomment -%}

  {% assign enriched_items = "" | split: "" %}
  {% for idx in (0..filtered_items.size-1) %}
    {% assign enriched_items = enriched_items | push: {"item": filtered_items[idx], "key": sort_keys[idx]} %}
  {% endfor %}
  {% assign sorted_items = enriched_items | sort: "key" %}

  <ul>
  {% for entry in sorted_items %}
    {% assign item = entry.item %}
    {%- comment -%} Construct display text {%- endcomment -%}
    {% assign display_text = item.title %}
    {%- assign info_parts = "" | split: "" -%}

    {%- if item.class -%}
      {% assign info_parts = info_parts | push: item.class | append: "-class" %}
    {%- endif -%}

    {%- if item.released -%}
      {% assign info_parts = info_parts | push: "released in " | append: item.released %}
    {%- endif -%}

    {%- if info_parts.size > 0 -%}
      {% assign info_text = info_parts | join: ", " %}
      {% assign display_text = display_text | append: " (" | append: info_text | append: ")" %}
    {%- endif -%}

    <li>
      {% if item.documented == "stub" %}
        {{ display_text }} <em>— documentation pending</em>
      {% else %}
        <a href="{{ item.url | relative_url }}">{{ display_text }}</a>
        {% if item.documented != "done" %} <em>— documentation in progress</em>{% endif %}
      {% endif %}
    </li>
  {% endfor %}
  </ul>
{% endfor %}